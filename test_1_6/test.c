#define  _CRT_SECURE_NO_WARNINGS 1


#include <stdio.h>

//1.
//输出什么？
// 
//#include <stdio.h>
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	return 0;
//}

//百度2015年系统工程师笔试题：
//请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。
//
//#include <stdio.h>
//
//int check_sys(int* p)
//{
//	return *((char*)(p));//先将int*转换成char*截断拿到第一个字节内容，直接解引用返回即可
//}
//
//int main()
//{
//	int a = 1;
//	//00 00 00 01
//	//01 00 00 00
//	int ret=check_sys(&a);//实现判断的函数
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}
//


int main()
{
	int n = 9;
	//9可以表示为
	//0x 00 00 00 09 //十六进制
	//0000 0000 0000 0000 0000 0000 0000 1001 //二进制
	// 
	//s=0,e=00000000,m=00000000000000000010001
	//e全为0，e=1-127=-126,所以表示为0.xxxxxxx,不再补有效位的第一个1，
	//直接写成(-1)^0*0.00000000000000000001001*2^(-126)
	//这个数非常非常非常小，所以以%f的形式去打印打印出来的当然是0了
	//
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat); //以浮点数的角度看待打印出的是0
	
	*pFloat = 9.0;
	//将9.0去还原出它的二进制1001.0
	//表示为 (-1)^0*1.001*2^3
	// s=0,m=001(舍弃前面的1)，e=3
	// e存入的是3+127=130 即10000010
	//0 10000010 001 00000000000000000000 //9.0的二进制序列
	//用整型的角度来看待这个二进制序列，转换成原码
	//00111110111011111111111111111111
	//这就是一个相当大的数字了
	//
	printf("num的值为：%d\n", n);//以整型的角度去看待浮点数打印出特别大的一个值
	printf("*pFloat的值为：%f\n", *pFloat);
	return 0;
}


//#include <stdio.h>
//
//int main()
//{
//	float a = 0.5f;
//	0011 1111 0000 0000 0000 0000 0000
//	3f 00 00 00
//	return 0;
//}
//

